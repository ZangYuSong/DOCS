# 原型链

JavaScript 中，万物皆对象。对象分为普通对象和函数对象。所有通过 `new Function()` 创建的叫函数对象对象。

函数对象包含一个属性 `prototype` 指向函数的**原型对象**。

所有的对象都包含下边两个属性：

- \_\_proto\_\_: 指向当前实例所属类的原型（`prototype`）。，一级一级向上查找最终指向 `null`。
- constructor: 指向的是一个函数对象，一级一级向上查找最终指向 `function`。
- 也就是 `a.__proto__ === a.constructor.prototype`

**原型对象**就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

**原型链**：当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找，直到找到 Object 对象的原型，Object 对象的原型没有原型也就是（null），如果在 Object 原型中依然没有找到，则返回 undefined。

# 作用域链

在 Javascript 中，作用域分为 **全局作用域** 和 **局部作用域**。

全局作用域：在代码中任何地方都能访问到的对象拥有全局作用域。

- **最外层函数**和在最外层函数外面定义的**变量**拥有全局作用域。
- 所有**末定义直接赋值**的变量自动声明为拥有全局作用域。
- 所有 window 对象的属性拥有全局作用域。

局部作用域：只在固定的代码片段内可访问到

作用域有上下级关系，上下级关系的确定就看函数是在哪个作用域下创建的。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

**作用域链**：当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法搜索到某个变量时，引擎就会在外层嵌套的作用域中继续搜索，直到搜索到该变量，或抵达最外层的作用域（也就是全局作用域）为止。这样一条有序的列表，称为作用域链，作用域链的最前端一定是当前作用域。

# 闭包

- 表现形式：一个函数执行返回一个新的函数，这个新函数使用了之前函数作用域下的变量。这就形成了闭包。
- 作用：让函数外部可以访问到函数内部的变量。

总结下来：闭包是指有权访问**另一个函数**作用域中的变量的**函数**

先看一个示例：

```js
function a() {
  var a = 1;
  console.log(a++);
}
a(); // 1
a(); // 1
a(); // 1

function b() {
  var a = 1;
  return function () {
    console.log(a++);
  };
}
c = b();
c(); // 1
c(); // 2
c(); // 3
```

如上示例，普通函数执行完成之后会销毁对应的变量。每次调用时候重新创建。但是当我们使用闭包的时候则不会销毁，而是保存在内存中。当我们大量使用了闭包就造成网页的性能问题，IE 中有可能造成内存泄漏。

## JS 继承
